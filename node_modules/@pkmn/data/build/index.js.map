{"version":3,"sources":["/Users/kjs/Code/src/github.com/pkmn/ps/data/build/index.js","../index.ts"],"names":[],"mappings":"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","file":"/Users/kjs/Code/src/github.com/pkmn/ps/data/build/index.js","sourcesContent":[null,"import {\n  AbilityName,\n  Condition,\n  Data,\n  Dex,\n  Species as DexSpecies,\n  Type as DexType,\n  EggGroup,\n  EvoType,\n  FormeName,\n  GenderName,\n  GenerationNum,\n  ID,\n  ItemName,\n  Move,\n  MoveCategory,\n  MoveName,\n  MoveSource,\n  Nature,\n  Nonstandard,\n  SpeciesAbility,\n  SpeciesName,\n  SpeciesTag,\n  StatID,\n  StatsTable,\n  Tier,\n  TypeName,\n} from '@pkmn/dex-types';\n\nconst DEFAULT_EXISTS = (d: Data) => {\n  if (!d.exists) return false;\n  if ('isNonstandard' in d && d.isNonstandard) return false;\n  if (d.kind === 'Ability' && d.id === 'noability') return false;\n  return !('tier' in d && ['Illegal', 'Unreleased'].includes(d.tier));\n};\n\nconst tr = (num: number, bits = 0) => bits ? (num >>> 0) % (2 ** bits) : num >>> 0;\n\nexport type ExistsFn = (d: Data, g: GenerationNum) => boolean;\ntype BoundExistsFn = (d: Data) => boolean;\n\nfunction assignWithout(a: {[key: string]: any}, b: {[key: string]: any}, exclude: Set<string>) {\n  for (const key in b) {\n    if (Object.prototype.hasOwnProperty.call(b, key) && !exclude.has(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n}\n\nexport function toID(text: any): ID {\n  if (text?.id) text = text.id;\n  if (typeof text !== 'string' && typeof text !== 'number') return '';\n  return ('' + text).toLowerCase().replace(/[^a-z0-9]+/g, '') as ID;\n}\n\nexport class Generations {\n  /* private */ readonly cache = Object.create(null) as {[num: number]: Generation};\n\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: ExistsFn;\n\n  static DEFAULT_EXISTS = DEFAULT_EXISTS;\n\n  constructor(dex: Dex, exists = Generations.DEFAULT_EXISTS) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(g: string | number) {\n    // May not actually be a GenerationNum, but isNaN and Dex.forGen will validate the rest\n    const gen = (typeof g === 'string' ? parseInt(g.slice(g.search(/\\d/))) : g) as GenerationNum;\n    if (isNaN(+gen)) throw new Error(`Invalid gen ${g}`);\n    if (this.cache[gen]) return this.cache[gen];\n    return (this.cache[gen] = new Generation(this.dex.forGen(gen), d => this.exists(d, gen)));\n  }\n\n  *[Symbol.iterator]() {\n    for (let gen = 1; gen <= 9; gen++) {\n      yield this.get(gen as GenerationNum);\n    }\n  }\n}\n\nexport class Generation {\n  readonly abilities: Abilities;\n  readonly items: Items;\n  readonly moves: Moves;\n  readonly species: Species;\n  readonly types: Types;\n  readonly natures: Natures;\n  readonly learnsets: Learnsets;\n  readonly conditions: Conditions;\n  readonly stats: Stats;\n\n  readonly dex: Dex;\n\n  /* private */ readonly exists: BoundExistsFn;\n\n  static get(dex: Dex, g: string | number, exists = DEFAULT_EXISTS) {\n    return new Generations(dex, exists).get(g);\n  }\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n\n    this.abilities = new Abilities(this.dex, this.exists);\n    this.items = new Items(this.dex, this.exists);\n    this.moves = new Moves(this.dex, this.exists);\n    this.species = new Species(this.dex, this.exists);\n    this.natures = new Natures(this.dex, this.exists);\n    this.types = new Types(this.dex, this.exists);\n    this.learnsets = new Learnsets(this, this.dex, this.exists);\n    this.conditions = new Conditions(this.dex, this.exists);\n    this.stats = new Stats(this.dex);\n  }\n\n  get num() {\n    return this.dex.gen;\n  }\n\n  toString() {\n    return `[Generation:${this.num}]`;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexport class Abilities {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const ability = this.dex.abilities.get(name);\n    return this.exists(ability) ? ability : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const ability in this.dex.data.Abilities) {\n      const a = this.get(ability);\n      if (a) yield a;\n    }\n  }\n}\n\nexport class Items {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const item = this.dex.items.get(name);\n    return this.exists(item) ? item : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const item in this.dex.data.Items) {\n      const i = this.get(item);\n      if (i) yield i;\n    }\n  }\n}\n\nexport class Moves {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const move = this.dex.moves.get(name);\n    return this.exists(move) ? move : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const move in this.dex.data.Moves) {\n      const m = this.get(move);\n      if (m) yield m;\n    }\n  }\n}\n\nexport class Species {\n  /* private */ readonly cache = Object.create(null) as {[id: string]: Specie};\n\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const species = this.dex.species.get(name);\n    if (!this.exists(species)) return undefined;\n    const id = (species as any).speciesid || species.id; // FIXME Event-only ability hack\n    const cached = this.cache[id];\n    if (cached) return cached;\n    return (this.cache[id] = new Specie(this.dex, this.exists, species));\n  }\n\n  *[Symbol.iterator]() {\n    for (const species in this.dex.data.Species) {\n      const s = this.get(species);\n      if (s) yield s;\n    }\n  }\n}\n\nexport class Specie implements DexSpecies {\n  readonly id!: ID;\n  readonly name!: SpeciesName;\n  readonly fullname!: string;\n  readonly exists!: boolean;\n  readonly num!: number;\n  readonly gen!: GenerationNum;\n  readonly shortDesc!: string;\n  readonly desc!: string;\n  readonly isNonstandard!: Nonstandard | null;\n  readonly duration?: number;\n\n  readonly effectType!: 'Pokemon';\n  readonly kind!: 'Species';\n  readonly baseStats!: StatsTable;\n  readonly baseSpecies!: SpeciesName;\n  readonly baseForme!: FormeName | '';\n  readonly forme!: FormeName | '';\n  readonly abilities!: SpeciesAbility<AbilityName | ''>;\n  readonly types!: [TypeName] | [TypeName, TypeName];\n  readonly prevo?: SpeciesName | '';\n  readonly evos?: SpeciesName[];\n  readonly nfe: boolean;\n  readonly eggGroups!: EggGroup[];\n  readonly weightkg!: number;\n  readonly weighthg!: number;\n  readonly tags!: SpeciesTag[];\n  readonly unreleasedHidden!: boolean | 'Past';\n  readonly maleOnlyHidden!: boolean;\n  readonly inheritsFrom!: ID;\n  readonly tier!: Tier.Singles | Tier.Other;\n  readonly doublesTier!: Tier.Doubles | Tier.Other;\n  readonly natDexTier!: Tier.Singles | Tier.Other;\n\n  readonly changesFrom?: SpeciesName;\n  readonly cosmeticFormes?: SpeciesName[];\n  readonly otherFormes?: SpeciesName[];\n  readonly formeOrder?: SpeciesName[];\n  readonly formes?: SpeciesName[];\n  readonly genderRatio: {M: number; F: number};\n  readonly isMega?: boolean;\n  readonly isPrimal?: boolean;\n  readonly battleOnly?: SpeciesName | SpeciesName[];\n  readonly canGigantamax?: MoveName;\n  readonly gmaxUnreleased?: boolean;\n  readonly cannotDynamax?: boolean;\n  readonly requiredAbility?: AbilityName;\n  readonly requiredItem?: ItemName;\n  readonly requiredItems?: ItemName[];\n  readonly requiredMove?: MoveName;\n  readonly gender?: GenderName;\n  readonly maxHP?: number;\n  readonly evoMove?: MoveName;\n  readonly evoItem?: string;\n  readonly evoRegion?: 'Alola' | 'Galar';\n  readonly evoLevel?: number;\n  readonly evoCondition?: string;\n  readonly evoType?: EvoType;\n  readonly condition?: Partial<Condition>;\n  readonly canHatch!: boolean;\n\n  /* private */ readonly dex: Dex;\n\n  /* private */ static readonly EXCLUDE = new Set([\n    'abilities', 'cosmeticFormes', 'evos', 'formeOrder',\n    'gender', 'genderRatio', 'nfe', 'otherFormes', 'prevo',\n  ]);\n\n  constructor(dex: Dex, exists: BoundExistsFn, species: DexSpecies) {\n    assignWithout(this, species, Specie.EXCLUDE);\n    this.dex = dex;\n    if (this.dex.gen >= 2) {\n      this.gender = species.gender;\n      this.genderRatio = species.genderRatio;\n    } else {\n      this.genderRatio = {M: 0, F: 0};\n    }\n    if (this.dex.gen >= 3) {\n      this.abilities = {0: species.abilities[0]};\n      // \"because PS\", Pokemon have the abilities that were added in Gen 4 in Gen 3 :bigthonk:\n      if (species.abilities[1] &&\n          this.dex.abilities.get(species.abilities[1]).gen <= this.dex.gen) {\n        this.abilities[1] = species.abilities[1];\n      }\n      if (this.dex.gen >= 5 && species.abilities.H) this.abilities.H = species.abilities.H;\n      if (this.dex.gen >= 7 && species.abilities.S) this.abilities.S = species.abilities.S;\n    } else {\n      this.abilities = {0: ''};\n    }\n    this.evos = species.evos?.filter(s => exists(this.dex.species.get(s)));\n    this.nfe = !!this.evos?.length;\n    if (!this.nfe) this.evos = undefined;\n    this.cosmeticFormes = species.cosmeticFormes?.filter(s => exists(this.dex.species.get(s)));\n    if (!this.cosmeticFormes?.length) this.cosmeticFormes = undefined;\n    this.otherFormes = species.otherFormes?.filter(s => exists(this.dex.species.get(s)));\n    if (!this.otherFormes?.length) this.otherFormes = undefined;\n    this.formeOrder = species.formeOrder?.filter(s => exists(this.dex.species.get(s)));\n    if (!this.formeOrder || this.formeOrder.length <= 1) this.formeOrder = undefined;\n    this.formes = this.formeOrder?.filter(s =>\n      this.dex.species.get(s).isNonstandard !== 'Gigantamax');\n    this.prevo =\n      species.prevo && exists(this.dex.species.get(species.prevo)) ? species.prevo : undefined;\n  }\n\n  get formeNum() {\n    return (this.baseSpecies === this.name\n      ? this.formeOrder ? this.formeOrder.findIndex(name => name === this.name) : 0\n      : this.dex.species.get(this.baseSpecies).formeOrder!.findIndex(\n        name => name === (this.isNonstandard === 'Gigantamax' ? this.baseSpecies : this.name)\n      ));\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return assignWithout({}, this, new Set(['dex']));\n  }\n}\n\nexport class Conditions {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const condition = this.dex.conditions.get(name);\n    return this.exists(condition) ? condition : undefined;\n  }\n}\n\nexport class Natures {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    if (this.dex.gen < 3) return undefined;\n    const nature = this.dex.natures.get(name);\n    return this.exists(nature) ? nature : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const nature in this.dex.data.Natures) {\n      const n = this.get(nature);\n      if (n) yield n;\n    }\n  }\n}\n\nconst EFFECTIVENESS = {\n  '-3': 0.125,\n  '-2': 0.25,\n  '-1': 0.5,\n  '0': 1,\n  '1': 2,\n  '2': 4,\n  '3': 8,\n};\n\ntype TypeTarget = {getTypes: () => TypeName[]} | {types: TypeName[]} | TypeName[] | TypeName;\n\nexport class Types {\n  /* private */ readonly cache = Object.create(null) as {[id: string]: Type};\n\n  /* private */ readonly unknown: Type;\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n    // PS doesn't contain data for the '???' type\n    this.unknown = new Type({\n      effectType: 'Type',\n      kind: 'Type',\n      // Regrettably PS ID's can't represent '???'\n      id: '',\n      name: '???',\n      // Technically this only exists as a true type in Gens 2-4, but there are moves dealing\n      // typeless damage in Gen 1 so we include it there.\n      exists: dex.gen <= 4,\n      gen: 1,\n      // This gets filled in for us by Type's constructor\n      damageTaken: {} as {[t in Exclude<TypeName, '???'>]: number},\n      HPivs: {},\n      HPdvs: {},\n    }, dex, this);\n  }\n\n  get(name: string) {\n    if (name === '???' && this.dex.gen >= 2 && this.dex.gen <= 4) return this.unknown;\n    const type = this.dex.types.get(name);\n    if (!this.exists(type)) return undefined;\n    const cached = this.cache[type.id];\n    if (cached) return cached;\n    return (this.cache[type.id] = new Type(type, this.dex, this));\n  }\n\n  *[Symbol.iterator]() {\n    for (const type in this.dex.data.Types) {\n      const t = this.get(type);\n      if (t) yield t;\n    }\n    if (this.dex.gen >= 2 && this.dex.gen <= 4) {\n      yield this.unknown;\n    }\n  }\n\n  getHiddenPower(ivs: StatsTable) {\n    return this.dex.getHiddenPower(ivs);\n  }\n\n  canDamage(source: {type: TypeName} | TypeName, target: TypeTarget) {\n    return this.dex.getImmunity(source, target);\n  }\n\n  totalEffectiveness(source: {type: TypeName} | TypeName, target: TypeTarget) {\n    if (!this.canDamage(source, target)) return 0;\n    const e = `${this.dex.getEffectiveness(source, target)}`;\n    // convert from PS's ridiculous encoding to something usable\n    return EFFECTIVENESS[e as keyof typeof EFFECTIVENESS];\n  }\n}\n\nexport type TypeEffectiveness = 0 | 0.5 | 1 | 2;\n\nconst DAMAGE_TAKEN = [1, 2, 0.5, 0] as TypeEffectiveness[];\nconst SPECIAL = ['Fire', 'Water', 'Grass', 'Electric', 'Ice', 'Psychic', 'Dark', 'Dragon'];\n\nexport class Type {\n  readonly id!: ID;\n  readonly name!: TypeName;\n  readonly effectType!: 'Type';\n  readonly kind!: 'Type';\n  readonly exists!: boolean;\n  readonly gen!: GenerationNum;\n  readonly effectiveness: {[t in TypeName]: TypeEffectiveness};\n  readonly HPivs!: Partial<StatsTable>;\n  readonly HPdvs!: Partial<StatsTable>;\n  readonly category?: Exclude<MoveCategory, 'Status'>;\n\n  /* private */ readonly types: Types;\n\n  constructor(type: DexType, dex: Dex, types: Types) {\n    Object.assign(this, type);\n    this.types = types;\n    this.category = ['Fairy', 'Stellar'].includes(this.name)\n      ? undefined : SPECIAL.includes(this.name) ? 'Special' : 'Physical';\n    // convert from PS's ridiculous encoding to something usable (plus damage taken -> dealt)\n    this.effectiveness = {'???': 1} as {[t in TypeName]: TypeEffectiveness};\n    for (const k in dex.data.Types) {\n      const t = k.charAt(0).toUpperCase() + k.slice(1) as Exclude<TypeName, '???'>;\n      const data = dex.data.Types[k as Lowercase<string>];\n      this.effectiveness[t] = DAMAGE_TAKEN[data.damageTaken[this.name] || 0];\n    }\n  }\n\n  canDamage(target: TypeTarget) {\n    return this.types.canDamage(this.name, target);\n  }\n\n  totalEffectiveness(target: TypeTarget) {\n    return this.types.totalEffectiveness(this.name, target);\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return assignWithout({}, this, new Set(['types']));\n  }\n}\n\nconst GEN3_HMS =\n  new Set(['cut', 'fly', 'surf', 'strength', 'flash', 'rocksmash', 'waterfall', 'dive'] as ID[]);\n// NOTE: Whirlpool and Defog are Gen 4 HMs but the HMs differ in DPPt vs. HGSS\nconst GEN4_HMS =\n  new Set(['cut', 'fly', 'surf', 'strength', 'rocksmash', 'waterfall', 'rockclimb'] as ID[]);\n\ntype Restriction = 'Pentagon' | 'Plus' | 'Galar' | 'Paldea';\n\nexport class Learnsets {\n  /* private */ readonly cache = Object.create(null) as {\n    [speciesid: string]: {[moveid: string]: MoveSource[]};\n  };\n\n  /* private */ readonly gen: Generation;\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(gen: Generation, dex: Dex, exists: BoundExistsFn) {\n    this.gen = gen;\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  async get(name: string) {\n    const learnset = await this.dex.learnsets.get(toID(name));\n    return this.exists(learnset) ? learnset : undefined;\n  }\n\n  async *[Symbol.iterator]() {\n    if (!this.dex.data.Learnsets) await this.dex.learnsets.get('LOAD' as ID);\n    for (const id in this.dex.data.Learnsets) {\n      const l = await this.get(id);\n      if (l) yield l;\n    }\n  }\n\n  async* all(species: Specie) {\n    let id = species.id;\n    let learnset = await this.get(id);\n    if (!learnset) {\n      id = typeof species.battleOnly === 'string' && species.battleOnly !== species.baseSpecies\n        ? toID(species.battleOnly)\n        : toID(species.baseSpecies);\n      learnset = await this.get(id);\n    }\n\n    while (learnset) {\n      yield learnset;\n\n      if (id === 'lycanrocdusk' || (species.id === 'rockruff' && id === 'rockruff')) {\n        id = 'rockruffdusk' as ID;\n      } else if (species.id === 'gastrodoneast') {\n        id = 'gastrodon' as ID;\n      } else if (species.id === 'pumpkaboosuper') {\n        id = 'pumpkaboo' as ID;\n      } else {\n        id = toID(species.battleOnly || species.changesFrom || species.prevo);\n      }\n\n      if (!id) break;\n      const s = this.gen.species.get(id);\n      if (!s) break;\n      species = s;\n      learnset = await this.get(id);\n    }\n  }\n\n  // BUG: this only covers what Pokémon Showdown deems \"teambuilder legality\" - proper legality\n  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.\n  async learnable(name: string, restriction?: Restriction) {\n    const species = this.gen.species.get(name);\n    if (!species) return undefined;\n\n    if (!restriction) {\n      const cached = this.cache[species.id];\n      if (cached) return cached;\n    }\n\n    const moves: {[moveid: string]: MoveSource[]} = {};\n\n    for await (const learnset of this.all(species)) {\n      if (learnset.learnset) {\n        for (const moveid in learnset.learnset) {\n          const move = this.gen.moves.get(moveid);\n          if (move) {\n            const sources = learnset.learnset[moveid];\n            if (this.isLegal(move, sources, restriction || this.gen)) {\n              const filtered = sources.filter(s => +s.charAt(0) <= this.gen.num);\n              if (!filtered.length) continue;\n              if (moves[move.id]) {\n                // If we simply add filtered to moves[move.id] we may end up with some duplicates or\n                // situations where we have mixed learnset information. We assume that while\n                // moves[move.id] and filtered are already deduped, their union might not be, and\n                // thus iterate through looking for unique prefixes. For efficiency, instead of\n                // appending each deduped source from filtered to moves[move.id] immediately and\n                // making each subsequent iteration longer we make a list of the unique sources to\n                // add at the end. This is only safe given our assumption that filtered is unique\n                // internally to begin with.\n                const unique = [];\n                // These lists are all expected to be short arrays so this O(n^2) linear searching\n                // is still expected to be faster runtime-wise than a more sophisticated approach\n                loop: for (const source of filtered) {\n                  const prefix = source.slice(0, 2);\n                  // sadly Babel chokes on using an .every(...) here due to throwIfClosureRequired\n                  for (const s of moves[move.id]) if (s.startsWith(prefix)) continue loop;\n                  unique.push(source);\n                }\n                moves[move.id].push(...unique);\n              } else {\n                moves[move.id] = filtered;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (!restriction) this.cache[species.id] = moves;\n    return moves;\n  }\n\n  // BUG: this only covers what Pokémon Showdown deems \"teambuilder legality\" - proper legality\n  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.\n  async canLearn(name: string, move: Move | string, restriction?: Restriction) {\n    const species = this.gen.species.get(name);\n    if (!species) return false;\n\n    move = typeof move === 'string' && this.gen.moves.get(move) || move;\n    if (typeof move === 'string') return false;\n\n    for await (const learnset of this.all(species)) {\n      if (this.isLegal(move, learnset.learnset?.[move.id], restriction || this.gen)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // BUG: this only covers what Pokémon Showdown deems \"teambuilder legality\" - proper legality\n  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.\n  isLegal(move: Move, sources: MoveSource[] | undefined, gen: Generation | Restriction) {\n    if (!sources) return undefined;\n\n    const gens = sources.map(x => Number(x[0]));\n    const minGen = Math.min(...gens);\n    const vcOnly = (\n      minGen === 7 && sources.every(x => x[0] !== '7' || x === '7V') ||\n      minGen === 8 && sources.every(x => x[0] !== '8' || x === '8V')\n    );\n\n    if (gen === 'Pentagon') return gens.includes(6);\n    if (gen === 'Plus') return gens.includes(7) && !vcOnly;\n    if (gen === 'Galar') return gens.includes(8) && !vcOnly;\n    if (gen === 'Paldea') return gens.includes(9);\n\n    if (this.gen.num >= 3 && minGen <= 4 && (GEN3_HMS.has(move.id) || GEN4_HMS.has(move.id))) {\n      let legalGens = '';\n      let available = false;\n\n      if (minGen === 3) {\n        legalGens += '3';\n        available = true;\n      }\n      if (available) available = !GEN3_HMS.has(move.id);\n\n      if (available || gens.includes(4)) {\n        legalGens += '4';\n        available = true;\n      }\n      if (available) available = !GEN4_HMS.has(move.id);\n\n      const minUpperGen = available ? 5 : Math.min(...gens.filter(g => g > 4));\n      legalGens += '0123456789'.slice(minUpperGen);\n      return legalGens.includes(`${gen.num}`);\n    } else {\n      return '0123456789'.slice(minGen).includes(`${gen.num}`);\n    }\n  }\n}\n\nconst STATS = ['hp', 'atk', 'def', 'spe', 'spa', 'spd'] as const;\n\nconst NAMES: Readonly<{[name: string]: StatID}> = {\n  HP: 'hp', hp: 'hp',\n  Attack: 'atk', Atk: 'atk', atk: 'atk',\n  Defense: 'def', Def: 'def', def: 'def',\n  'Special Attack': 'spa', SpA: 'spa', SAtk: 'spa', SpAtk: 'spa', spa: 'spa',\n  Special: 'spa', spc: 'spa', Spc: 'spa',\n  'Special Defense': 'spd', SpD: 'spd', SDef: 'spd', SpDef: 'spd', spd: 'spd',\n  Speed: 'spe', Spe: 'spe', Spd: 'spe', spe: 'spe',\n};\n\nconst DISPLAY: Readonly<{[stat: string]: Readonly<[string, string]>}> = {\n  hp: ['HP', 'HP'],\n  atk: ['Atk', 'Attack'],\n  def: ['Def', 'Defense'],\n  spa: ['SpA', 'Special Attack'],\n  spd: ['SpD', 'Special Defense'],\n  spe: ['Spe', 'Speed'],\n  spc: ['Spc', 'Special'],\n};\n\nexport class Stats {\n  /* private */ readonly dex: Dex;\n\n  constructor(dex: Dex) {\n    this.dex = dex;\n  }\n\n  calc(stat: StatID, base: number, iv = 31, ev?: number, level = 100, nature?: Nature) {\n    if (ev === undefined) ev = this.dex.gen < 3 ? 252 : 0;\n    if (this.dex.gen < 3) {\n      iv = this.toDV(iv) * 2;\n      nature = undefined;\n    }\n    if (stat === 'hp') {\n      return base === 1 ? base : tr(tr(2 * base + iv + tr(ev / 4) + 100) * level / 100 + 10);\n    } else {\n      const val = tr(tr(2 * base + iv + tr(ev / 4)) * level / 100 + 5);\n      if (nature !== undefined) {\n        if (nature.plus === stat) return tr(tr(val * 110, 16) / 100);\n        if (nature.minus === stat) return tr(tr(val * 90, 16) / 100);\n      }\n      return val;\n    }\n  }\n\n  get(s: string): StatID | undefined {\n    return NAMES[s];\n  }\n\n  display(str: string, full = false): string {\n    let s: StatID | 'spc' | undefined = NAMES[str];\n    if (s === undefined) return str;\n    if (this.dex.gen === 1 && s === 'spa') s = 'spc';\n    return DISPLAY[s][+full];\n  }\n\n  fill<T>(stats: Partial<StatsTable<T>>, val: T): StatsTable<T> {\n    for (const stat of STATS) {\n      if (!(stat in stats)) stats[stat] = val;\n    }\n    return stats as StatsTable<T>;\n  }\n\n  getHPDV(ivs: Partial<StatsTable>): number {\n    return (\n      (this.toDV(ivs.atk === undefined ? 31 : ivs.atk) % 2) * 8 +\n      (this.toDV(ivs.def === undefined ? 31 : ivs.def) % 2) * 4 +\n      (this.toDV(ivs.spe === undefined ? 31 : ivs.spe) % 2) * 2 +\n      (this.toDV(ivs.spa === undefined ? 31 : ivs.spa) % 2)\n    );\n  }\n\n  *[Symbol.iterator](): IterableIterator<StatID> {\n    for (const s of STATS) {\n      yield s;\n    }\n  }\n\n  toDV(iv: number): number {\n    return Math.floor(iv / 2);\n  }\n\n  toIV(dv: number): number {\n    return dv * 2 + 1;\n  }\n}\n\nexport type {\n  ID,\n  As,\n  Weather,\n  FieldCondition,\n  SideCondition,\n  GenerationNum,\n  GenderName,\n  StatID,\n  StatsTable,\n  BoostID,\n  BoostsTable,\n  MoveCategory,\n  MoveTarget,\n  Nonstandard,\n  EvoType,\n  EggGroup,\n  SideID,\n  Player,\n  GameType,\n  HPColor,\n  StatusName,\n  NatureName,\n  TypeName,\n  HPTypeName,\n  Tier,\n  PokemonSet,\n  AbilityName,\n  ItemName,\n  MoveName,\n  SpeciesName,\n  FormeName,\n  EffectType,\n  Effect,\n  DataKind,\n  Data,\n  EffectData,\n  HitEffect,\n  SecondaryEffect,\n  ConditionData,\n  AbilityData,\n  ItemData,\n  MoveData,\n  SpeciesData,\n  MoveSource,\n  EventInfoData,\n  LearnsetData,\n  TypeData,\n  NatureData,\n  BasicEffect,\n  Condition,\n  Ability,\n  Item,\n  Move,\n  // Species,\n  EventInfo,\n  Learnset,\n  // Type,\n  Nature,\n  GenID,\n  Dex,\n} from '@pkmn/dex-types';\n"]}